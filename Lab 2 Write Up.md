#Introduction
In this lab, we created firmware for the controller we designed in lab 2. The requirements were that the left stick controls movement (through standard WASD input) and the right stick controls the mouse.

#Design Methodology
I used the example code for as much of the lab as was fitting. This means that the majority of the face keys the right analog stick were simply slightly modified sample code for writing to keyboard and moving mouse respectively. The left stick simply maps to the WASD keys after the analog stick has passed a certain threshold. This threshold was tuned to what felt natural relative to existing controllers.

The unique additions conist of an enable switch, a mode switch button, and 6 total buttons which were read as a single analog input. The switch was a simple on-off switch that was used as the condition for the rest of the code running. This allows the controller to be silenced when need be. A silence was chosen over a hardware shutoff since it prevents bugs such as improper pull-ups for occuring. Furthermore there is significant startup lag when first plugging in a controller, so a silence allows for the controller to switch between active and inactive states with zero delay.

The mode control button when pressed toggles the d-pad between serving as arrow keys and serving as mouse controls. When in control mode, the up and down buttons increase and decrease sensitivity respectively. Currently they adjust sensitivity linearly, which allows for much more precise sensitivity adjustments at the cost of lots of button presses. the alternative was to have the scale be exponential which would allow rapid sensitivity swings without a lot of user input. 

Ultimately, I will implement the exponential solution; however, since the next lab requires extensive testing of the controller between various people who might enjoy a wide range of sensitivities, I felt it was more important to have a finer resolution for this purpose. Thus, as the firmware works right now, the senstivity buttons are more for initially programming the controller to a single sensitivity and staying with it for a decent length of time rather than rapidly switching sensitivities in action.

The right and left d-pad buttons when in control mode affect the rate of acceleration. Initially, acceleration is 0 but can be increased. The acceleration when non-zero behaves similarly between all values with the only change being that the magnitude of the acceleration and not the duration.

The acceleration works by checking if the user is currently at the maximum position on the analog stick. If they are, the controller assumes the player wants to go faster (otherwise they would pull back a little on the stick). Every poll cycle (around 5ms) if the user is at the max value, the mouse sensitivy increases by 15% time the selected acceleration. For example, if a user is on sensitivity 2 and holds the stick all the way to the right for 15 ms, for the first 5 ms the mouse will move at regular speed, for the next 5 ms the mouse will move 30% faster (15% times 2), and for the last 5 ms the mouse will move 60% faster.

When the user pulls back from the max value, I initially found that the sudden deceleration was jarring for the user, so I chose to dial back the deceleration at a rate of 100% times the acceleration. Thus in our previous example, the mouse would have decelerated instantly, however, if the user had been holding the stick for 7 polling cycles or more, (which corresponds to at least 105% times acceleration max speed), the controller would not automatically snap back to base speed, but will step down by 100% every polling cycle. This feels a lot more natural but has one large downside, it makes the mouse movement less predictible since it is hard to get back to fine control after a long period of acceleration. Ultimately I decided to stick with the slower decelleration since I value usability over precision for a controller input since there exist much more precise control methods already in the way of a keyboard and mouse. 

The final deviation was the map from analog back to digital. This was achieved by simply having a large if-elseif block at the beginning of the code that mapped each range of analog values to a particular set of keys being pressed. This is very inefficient since for some of the latter cases, the code has to go through over 30 if evaluations. Because of  this, I placed the less time sensitive buttons (control button and start button) to correspond to the latter ranges while the more important shoulder and trigger buttons will usually happen in the first 10 to 15 if statements.

The more elegant solution here would be to create a bit association table so that certain bits of the analog input would set certain 'flag' bits within a control signal, then these flags would be used to determine which button had been pressed or not. Since I only, have 6 buttons being evaluated, 2 of them being rarely pressed, I felt that this was unneccessary, but if the cycle time of the loop is found to be too long, this is the first place that can be tremendously optimized.

Finally, I chose arbitrary key assignments for most keys since most modern games allow key rebinding in-game. The keys that I kept to be specific were as follows: the arrow keys were bound to the d-pad, WASD was bound to the left analog stick, enter was bound to start, and escape was bound to back. These are almost universal keys within games, so it was logical to code them as such. Furthermore many games do not allow you to rebind the keys that control the menu, so having the standard arrow keys, enter, and escape is useful for menu navigation.

#Testing Methodology

For testing, I first tested all of the standard digital buttons to make sure they printed their respective letters. If first found that they would only print the letter once even when held down. This was because I used the wrong arduino function, I changed the buttons to use the press function instead and they worked from then on.

I tested the analog to digital buttons by simply going through every combination of keys and making sure all 6 could be pressed in any combination. I tested this by outputting the raw button state rather than the key values since unless all the keys are pressed at precisely the same time, windows will only repeatedly print the latest pressed character. After all of these worked, I went back through and tested that each individual one worked as its designated key.

I then tested the analog sticks to make sure the thresholding and the range was working. I did this by printing the x and y mouse movement over serial. All of this seemed to work as expected. 

Next I tested toggling between d-pad and control, since this worked, I could start testing the control pad. I increased and decreased the sensitivity and wrote it to serial. I also moved the stick around to make sure it felt ok. I found that I initially had too low resolution on the sensitivity toggle, and that at the lower sensitivity ranges, the threshold would stop working and the mouse would drift. I fixed the former by changing the intensity of each level of the sensitivity and the latter by simply putting a min value on the threshold.

The acceleration was tested purely for feel and bugs. Ultimately, acceleration should not be used in games so it was more important that the acceleration feels good for general computer use. I first had tried to make the acceleration work well for games by having it rapidly accelerate with rapid movements and then decelerate automatically after a a couple cycles. This worked ok in games allowing for fast movements which would then slow down and become accurate (perfect for FPSs where readjusting aim requires a burst of speed followed by a period of high accuracy). However this did not translate at all to general browsing. It felt aweful to use in anything other than an FPS game so I removed and and implemented the reverse as described above. This feels less good in "twitch" based games, but such games are typically played with a mouse anyways so I felt optimizing for such games was a waste.

After all of the features checked out, I played a few games to see if it felt good. I mostly tested the controller with Dark Souls since that is the primary reason I use a controller on PC. I found that the controller performed extremly well under all circumstances except one: the keys weren't buffered. This meant that if the dodge button was pressed for a split second and that action did not get evaluated when it was pressed, the character would not dodge. This is a critical flaw in the controller that is currently unsolved. For most actions, this problem is not prevelent since the button is held down for a considerable amount of time, it is only with certain "twitch" actions such as dodging that the problem presents itself.

#Results and Discussion

After all of the features checked out, I played a few games to see if it felt good. I mostly tested the controller with Dark Souls since that is the primary reason I use a controller on PC. I found that the controller performed extremly well under all circumstances except one: the keys weren't buffered. This meant that if the dodge button was pressed for a split second and that action did not get evaluated when it was pressed, the character would not dodge. This is a critical flaw in the controller that is currently unsolved. For most actions, this problem is not prevelent since the button is held down for a considerable amount of time, it is only with certain "twitch" actions such as dodging that the problem presents itself.

Another issue with this design is that the left analog stick is mapped to digital inputs. This does not allow analog movement in games even though the user is using analog inputs making it feel very awkward in games. One possible solution would be to output a PWM of the key where the analog value of the joystick would control the duty cycle. In certain games (such as racing games) this would work great since the key is converted to a throttle in the game engine and the throttle amount would simply change. In other games that tend to model realistic movementsm, this would cause big problems since the engine would attempt to start and stop the character repeatedly. I currently have not implemented this solution, so I do not know how well it would actually perform.

#Conclusions

The controller behaves like a standard third party controller for PC. It works in games fine, feeling somewhere between using a keyboard and mouse and a controller. The biggest giveaway that the firmware is bound to a keyboard is that the movement is still digital, which in some games is instantly recognizable. 

I spend about 45 minutes doing the initial coding for the lab and then another hour and a half fine tuning the acceleration and sensitivity.
